# Golang 面试记录

## basic

1. Golang中数组和array的区别
    
    数组是一个固定长度且容量不可变的数据结构，它在定义时需要指定长度，每个元素的类型和长度必须一致。数组在内存中是连续的一块空间，访问效率高，但是由于其长度是固定的，所以很难满足动态扩容的需求。
    
    切片是一个动态的数据结构，由指向底层数组的指针、长度和容量组成。切片在创建时长度可以为空，其容量是底层数组的长度，可以随着元素的增加而自动扩容。切片相比数组具有更好的灵活性和扩展性，因为它可以动态改变长度和容量。
    
    可以用内置函数 **`len()`** 来获取切片和数组的长度，**`cap()`** 函数来获取切片的容量。
    
    下面是数组和切片的一些不同之处：
    
    1. 数组的长度是固定的，不可改变；而切片的长度和容量可以随着元素的增加而动态改变。
    2. 数组在传递参数时，是以值传递的方式进行的，而切片则是以引用传递的方式进行的。
    3. 数组的创建方式是 **`[n]T`**，例如 **`var arr [5]int`**；切片的创建方式是 **`[]T`**，例如 **`var slice []int`** 或者 **`slice := make([]int, 5)`**。
    4. 数组是一个值类型，两个数组之间的赋值是值拷贝，即会复制一份副本。切片是一个引用类型，对一个切片的修改会影响到所有引用该切片的变量。
    5. 在内存中，数组和切片的存储方式不同。数组是一个连续的内存块，每个元素的大小一样，所以可以通过指针算术运算来访问数组元素；而切片是一个包含三个信息的结构体，其中包括一个指向底层数组的指针、切片的长度和容量，所以访问切片元素时需要通过指针和索引计算元素的地址。
2. Golang中`new`和`make`的区别
    - **`new`** 用来创建一个类型的指针，并返回指针地址。该指针对应的值被置为零值。语法为：**`new(T)`**，其中 T 表示类型。例如，如果要创建一个 **`int`** 类型的指针，可以使用 **`new(int)`**。
    - **`make`** 用来创建一个特定类型的对象（如 slice、map 和 channel），并初始化该对象，返回对象本身。语法为：**`make(T, args)`**，其中 T 表示类型，args 是用来初始化对象的参数。例如，如果要创建一个 int 类型的 slice，可以使用 **`make([]int, 0)`**。
    
    需要注意的是，**`new`** 和 **`make`** 都只能用于创建内置类型（如基本类型、struct 等）或者命名类型（即使用 **`type`** 关键字定义的类型）。不能用于创建接口类型。另外，**`new`** 返回的是指针类型，**`make`** 返回的是值类型，因此在使用时需要注意类型的区别。
3. Golang 中 **`map`** 的使用场景
    1. 统计词频：将单词作为键，出现的次数作为值，可以用 map 来统计词频。
    2. 数据库查询结果映射：当使用数据库查询操作时，查询结果是一组键值对，这些键值对可以使用 map 来表示。在juzi使用
    3. 缓存：将计算的结果存储到 map 中，下次需要这个结果时可以直接从 map 中获取，避免重复计算。
    4. 索引：将某个属性的值作为键，将对象的引用作为值，可以使用 map 来实现对象的索引。
    5. 配置文件解析：将配置文件中的配置项以键值对的形式存储在 map 中，可以快速方便地读取配置。在juzi使用
    
    总的来说，map 可以用于存储无序的键值对数据，方便查找和读取，适合于快速的读取和更新操作，但在并发读写时需要注意并发安全问题。
4.  **`map`** 是并发安全的嘛
不是并发安全的。为了保证map的并发安全性，可以使用golang提供的sync包中的Mutex或者RWMutex进行加锁和解锁操作。另外，也可以使用并发安全的第三方map实现，例如sync.Map和concurrent-map等。